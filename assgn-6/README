Case Western Reserve University
EECS 338 Operating Systems
Assignment #6
Christian Gunderman
cdg46


STRUCTURE:
 client
   - client.c - client application entry point and code.
 server
   - server.c - server RPC function defs.
 protocol - RPC protocol definition.
   - proto.x  - RPC language protocol definition.
 extern - All my work, but work I completed before this class.
   - c-datastructs - My C datastructures library.
 README - this file.



BUILDING:
 To build EVERYTHING, run in project root:
 > make all
 OR to build EVERYTHING with debug symbols (CC -g), run in project root:
 > make all-debug



RUNNING:
 First, build with make.
 CLIENT: If incorrect args are given, client will display help info.
   ./client.sh [hostname] [command] 
 SERVER: No UI, simply blocks and waits for a request to come through.
   ./server.sh
 SCENARIOS:
   As decribed in the project prompt, I have provided 2 separate clients
   that log in with their hostname as the username. These are in the
   form of client1.sh and client2.sh.
   ./client1.sh [server_hostname]
   ./client2.sh [server_hostname]



MEMORY MANAGEMENT:
 I had a lot of trouble eliminating memory leaks while working on this
 project. RPC allocates a lot of memory and system resources, however,
 there aren't any easy ways to cleanly close the RPC server after a
 request. The client appears to leak too, even when I call all the
 destroy methods, but Valgrind traces these to the underlying RPC
 implementation and not my code. I did my best to ensure that all
 of my data are freed when messages/users are deleted, but since the server
 is terminated with Ctrl-C and has no cleanup methods, I'm letting
 the operating system handle cleaning up the actual datastructures.
 It's not ideal, but full solutions require messy signal handling
 or at exit handlers.



ASSUMPTIONS:
 I assumed that once a mailbox is created that it cannot be replaced
 without being destroyed first, however, I assumed that one message
 CAN replace another without the first being deleted first. I also
 assumed that it would be ok to not cleanup the RPC server memory
 since the main method is autogenerated and I don't have a clean
 way of exiting the server. Ctrl-C never frees the RPC memory and
 hashtable. Finally, I assumed that message numbers cannot be negative.



ORIGINALITY:
The contents of this package are 100% original and composed of my own work.
The extern folder is 100% my work, but datastructures and dependencies that
I completed and tested before taking this class. Carlin told me it would be
ok to use this prior work.